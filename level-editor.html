<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Level Editor</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: #f0f0f0;
      }

      .container {
        display: flex;
        gap: 20px;
      }

      .editor-panel {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        width: 300px;
        height: fit-content;
      }

      .canvas-container {
        flex: 1;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
      }

      canvas {
        border: 2px solid #ccc;
        cursor: crosshair;
      }

      .tool-group {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
      }

      .tool-group h3 {
        margin: 0 0 10px 0;
        color: #333;
      }

      .tool-button {
        display: block;
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        border: 2px solid #ddd;
        background: white;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .tool-button:hover {
        background: #f0f0f0;
      }

      .tool-button.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
      }

      .property-input {
        display: block;
        width: 100%;
        padding: 8px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
      }

      .export-button {
        background: #28a745;
        color: white;
        border: none;
        padding: 15px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        width: 100%;
        margin-top: 10px;
      }

      .export-button:hover {
        background: #218838;
      }

      .selected {
        box-shadow: 0 0 0 3px #007bff;
      }

      .coordinates {
        font-size: 12px;
        color: #666;
        margin-top: 10px;
      }

      textarea {
        width: 100%;
        height: 200px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="editor-panel">
        <h2>Level Editor</h2>

        <div class="tool-group">
          <h3>Tools</h3>
          <button class="tool-button active" data-tool="select">
            Select / Move
          </button>
          <button class="tool-button" data-tool="box">Add Box</button>
          <button class="tool-button" data-tool="player">Place Player</button>
          <button class="tool-button" data-tool="goal">Place Goal</button>
          <button class="tool-button" data-tool="pickup">Add Pickup</button>
          <button class="tool-button" data-tool="shuriken">Add Shuriken</button>
          <button class="tool-button" data-tool="rope">Add Rope Point</button>
          <button class="tool-button" data-tool="laser">Add Laser</button>
          <button class="tool-button" data-tool="background">
            Edit Background
          </button>
        </div>

        <div class="tool-group" id="properties">
          <h3>Properties</h3>
          <div id="property-fields"></div>
        </div>

        <div class="tool-group">
          <h3>Actions</h3>
          <button class="tool-button" onclick="deleteSelected()">
            Delete Selected
          </button>
          <button class="tool-button" onclick="clearLevel()">
            Clear Level
          </button>
        </div>

        <div class="coordinates" id="coordinates">Mouse: (0, 0)</div>

        <button class="export-button" onclick="exportLevel()">
          Export Level
        </button>

        <button
          class="export-button"
          onclick="importLevel()"
          style="background: #007bff; margin-top: 5px"
        >
          Import Level
        </button>

        <div class="tool-group">
          <h3>Generated Code</h3>
          <textarea
            id="output"
            placeholder="Paste level code here to import, or generate code by clicking Export Level..."
          ></textarea>
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="canvas" width="1200" height="800"></canvas>
      </div>
    </div>

    <script>
      class LevelEditor {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.currentTool = "select";
          this.selectedObject = null;
          this.isDragging = false;
          this.dragOffset = { x: 0, y: 0 };
          this.isResizing = false;
          this.resizeHandle = null;
          this.scale = 0.25; // Make 1 unit appear 4x smaller (0.25x scale)
          this.selectedBackgroundPoint = null; // For background editing
          this.backgroundPointIndex = -1; // Index of selected background point

          this.level = {
            playerPos: { x: 100, y: 400 },
            goalPos: { x: 1000, y: 400 },
            background: {
              positions: [
                { x: 100, y: 100 },
                { x: 1300, y: 100 },
                { x: 1300, y: 900 },
                { x: 100, y: 900 },
              ],
            },
            objects: [],
          };

          this.setupEventListeners();
          this.render();
        }
        setupEventListeners() {
          this.canvas.addEventListener(
            "mousedown",
            this.onMouseDown.bind(this)
          );
          this.canvas.addEventListener(
            "mousemove",
            this.onMouseMove.bind(this)
          );
          this.canvas.addEventListener("mouseup", this.onMouseUp.bind(this));

          document.addEventListener("keydown", (e) => {
            if (e.key === "Delete" && this.selectedObject) {
              this.deleteSelected();
            }
          });

          document.querySelectorAll(".tool-button").forEach((button) => {
            button.addEventListener("click", (e) => {
              if (e.target.dataset.tool) {
                this.setTool(e.target.dataset.tool);
              }
            });
          });
        }

        setTool(tool) {
          this.currentTool = tool;
          this.selectedObject = null;
          document.querySelectorAll(".tool-button").forEach((btn) => {
            btn.classList.remove("active");
          });
          document
            .querySelector(`[data-tool="${tool}"]`)
            .classList.add("active");
          this.updatePropertyPanel();
          this.render();
        }

        onMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const canvasX = e.clientX - rect.left;
          const canvasY = e.clientY - rect.top;
          // Convert canvas coordinates to world coordinates
          const x = canvasX / this.scale;
          const y = canvasY / this.scale;

          if (this.currentTool === "select") {
            const obj = this.getObjectAt(x, y);
            if (obj) {
              // Check if clicking on a resize handle of the currently selected box
              if (
                obj.type === "box" &&
                this.selectedObject &&
                this.selectedObject.type === "box" &&
                this.selectedObject.ref === obj.ref
              ) {
                const handle = this.getResizeHandle(x, y, obj);
                if (handle) {
                  this.isResizing = true;
                  this.resizeHandle = handle;
                  this.selectedObject = obj;
                  return;
                }
              }

              this.selectedObject = obj;
              this.isDragging = true;
              this.dragOffset.x = x - obj.x;
              this.dragOffset.y = y - obj.y;
              this.isResizing = false;
              this.resizeHandle = null;

              // Special handling for background points
              if (obj.type === "backgroundPoint") {
                this.selectedBackgroundPoint = this.level.background;
                // Find the point index
                this.backgroundPointIndex =
                  this.level.background.positions.findIndex(
                    (pos) => pos.x === obj.x && pos.y === obj.y
                  );
              } else {
                this.selectedBackgroundPoint = null;
                this.backgroundPointIndex = -1;
              }
            } else {
              this.selectedObject = null;
              this.selectedBackgroundPoint = null;
              this.backgroundPointIndex = -1;
              this.isResizing = false;
              this.resizeHandle = null;
            }
          } else if (this.currentTool === "background") {
            // Check if clicking on an existing background point
            const obj = this.getObjectAt(x, y);
            if (obj && obj.type === "backgroundPoint") {
              this.selectedObject = obj;
              this.isDragging = true;
              this.dragOffset.x = x - obj.x;
              this.dragOffset.y = y - obj.y;
              this.selectedBackgroundPoint = this.level.background;
              this.backgroundPointIndex =
                this.level.background.positions.findIndex(
                  (pos) => pos.x === obj.x && pos.y === obj.y
                );
            } else {
              // Place a new background point
              this.placeObject(x, y);
            }
          } else {
            this.placeObject(x, y);
          }

          this.updatePropertyPanel();
          this.render();
        }

        onMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const canvasX = e.clientX - rect.left;
          const canvasY = e.clientY - rect.top;
          // Convert canvas coordinates to world coordinates
          const x = canvasX / this.scale;
          const y = canvasY / this.scale;

          document.getElementById(
            "coordinates"
          ).textContent = `Mouse: (${Math.round(x)}, ${Math.round(y)})`;

          if (
            this.isResizing &&
            this.selectedObject &&
            this.selectedObject.type === "box"
          ) {
            this.resizeObject(x, y);
            this.updateObjectReference();
            this.updatePropertyPanel();
            this.render();
          } else if (this.isDragging && this.selectedObject) {
            this.selectedObject.x = x - this.dragOffset.x;
            this.selectedObject.y = y - this.dragOffset.y;
            this.updateObjectReference();
            this.updatePropertyPanel();
            this.render();
          }
        }

        onMouseUp(e) {
          if (this.isResizing && this.selectedObject) {
            // Round dimensions to clean values when releasing mouse
            this.selectedObject.x = Math.round(this.selectedObject.x);
            this.selectedObject.y = Math.round(this.selectedObject.y);
            this.selectedObject.width = Math.round(this.selectedObject.width);
            this.selectedObject.height = Math.round(this.selectedObject.height);

            // Update the object reference with rounded values
            this.updateObjectReference();

            // Update the property panel to show the new rounded values
            this.updatePropertyPanel();

            // Re-render with the new snapped dimensions
            this.render();
          } else if (this.isDragging && this.selectedObject) {
            // Round coordinates to clean values when releasing mouse
            this.selectedObject.x = Math.round(this.selectedObject.x);
            this.selectedObject.y = Math.round(this.selectedObject.y);

            // Update the object reference with rounded values
            this.updateObjectReference();

            // Update the property panel to show the new rounded values
            this.updatePropertyPanel();

            // Re-render with the new snapped position
            this.render();
          }

          this.isDragging = false;
          this.isResizing = false;
          this.resizeHandle = null;
        }

        getObjectAt(x, y) {
          // Check background points first when in background edit mode for priority selection
          if (this.currentTool === "background") {
            if (this.level.background && this.level.background.positions) {
              for (let i = 0; i < this.level.background.positions.length; i++) {
                const pos = this.level.background.positions[i];
                if (this.isPointInCircle(x, y, pos.x, pos.y, 15)) {
                  return {
                    type: "backgroundPoint",
                    x: pos.x,
                    y: pos.y,
                  };
                }
              }
            }
          }

          // Check player
          if (
            this.isPointInCircle(
              x,
              y,
              this.level.playerPos.x,
              this.level.playerPos.y,
              20
            )
          ) {
            return { type: "player", ...this.level.playerPos };
          }

          // Check goal
          if (
            this.isPointInCircle(
              x,
              y,
              this.level.goalPos.x,
              this.level.goalPos.y,
              30
            )
          ) {
            return { type: "goal", ...this.level.goalPos };
          }

          // Check objects
          for (let obj of this.level.objects) {
            if (
              obj.box &&
              this.isPointInRect(
                x,
                y,
                obj.box.pos.x,
                obj.box.pos.y,
                obj.box.width,
                obj.box.height
              )
            ) {
              return {
                type: "box",
                ...obj.box.pos,
                width: obj.box.width,
                height: obj.box.height,
                canBounce: obj.box.canBounce || false,
                zIndex: obj.zIndex || 0,
                ref: obj,
              };
            }
            if (
              obj.pickup &&
              this.isPointInCircle(x, y, obj.pickup.pos.x, obj.pickup.pos.y, 15)
            ) {
              return { type: "pickup", ...obj.pickup.pos, ref: obj };
            }
            if (
              obj.shuriken &&
              this.isPointInCircle(
                x,
                y,
                obj.shuriken.pos.x,
                obj.shuriken.pos.y,
                20
              )
            ) {
              return { type: "shuriken", ...obj.shuriken.pos, ref: obj };
            }
            if (
              obj.ropeContactPoint &&
              this.isPointInCircle(
                x,
                y,
                obj.ropeContactPoint.pos.x,
                obj.ropeContactPoint.pos.y,
                40
              )
            ) {
              return {
                type: "rope",
                ...obj.ropeContactPoint.pos,
                canActivate: obj.ropeContactPoint.canActivate || false,
                isActive: obj.ropeContactPoint.isActive !== false, // Default to true
                ...obj.ropeContactPoint.endPos,
                ref: obj,
              };
            }
            if (
              obj.laser &&
              this.isPointInCircle(
                x,
                y,
                obj.laser.startPoint.x,
                obj.laser.startPoint.y,
                20
              )
            ) {
              return {
                type: "laser",
                x: obj.laser.startPoint.x,
                y: obj.laser.startPoint.y,
                endX: obj.laser.endPoint.x,
                endY: obj.laser.endPoint.y,
                ref: obj,
              };
            }
          }

          // Check background points (only when in select mode, since background mode already checked above)
          if (this.currentTool === "select") {
            if (this.level.background && this.level.background.positions) {
              for (let i = 0; i < this.level.background.positions.length; i++) {
                const pos = this.level.background.positions[i];
                if (this.isPointInCircle(x, y, pos.x, pos.y, 15)) {
                  return {
                    type: "backgroundPoint",
                    x: pos.x,
                    y: pos.y,
                  };
                }
              }
            }
          }

          return null;
        }

        isPointInRect(px, py, x, y, w, h) {
          return px >= x && px <= x + w && py >= y && py <= y + h;
        }

        isPointInCircle(px, py, cx, cy, r) {
          const dx = px - cx;
          const dy = py - cy;
          return dx * dx + dy * dy <= r * r;
        }

        distanceToLineSegment(px, py, x1, y1, x2, y2) {
          // Calculate distance from point (px, py) to line segment (x1, y1) to (x2, y2)
          const A = px - x1;
          const B = py - y1;
          const C = x2 - x1;
          const D = y2 - y1;

          const dot = A * C + B * D;
          const lenSq = C * C + D * D;

          if (lenSq === 0) {
            // Line segment is actually a point
            return Math.sqrt(A * A + B * B);
          }

          let param = dot / lenSq;

          let xx, yy;

          if (param < 0) {
            xx = x1;
            yy = y1;
          } else if (param > 1) {
            xx = x2;
            yy = y2;
          } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
          }

          const dx = px - xx;
          const dy = py - yy;
          return Math.sqrt(dx * dx + dy * dy);
        }

        drawResizeHandles(box) {
          const handleSize = 8 / this.scale;
          const x = box.x;
          const y = box.y;
          const w = box.width;
          const h = box.height;

          this.ctx.fillStyle = "#007bff";
          this.ctx.strokeStyle = "#ffffff";
          this.ctx.lineWidth = 2 / this.scale;

          // Corner handles
          const handles = [
            { x: x, y: y, type: "nw" }, // Top-left
            { x: x + w, y: y, type: "ne" }, // Top-right
            { x: x + w, y: y + h, type: "se" }, // Bottom-right
            { x: x, y: y + h, type: "sw" }, // Bottom-left
            // Edge handles
            { x: x + w / 2, y: y, type: "n" }, // Top
            { x: x + w, y: y + h / 2, type: "e" }, // Right
            { x: x + w / 2, y: y + h, type: "s" }, // Bottom
            { x: x, y: y + h / 2, type: "w" }, // Left
          ];

          handles.forEach((handle) => {
            this.ctx.fillRect(
              handle.x - handleSize / 2,
              handle.y - handleSize / 2,
              handleSize,
              handleSize
            );
            this.ctx.strokeRect(
              handle.x - handleSize / 2,
              handle.y - handleSize / 2,
              handleSize,
              handleSize
            );
          });
        }

        getResizeHandle(x, y, box) {
          const handleSize = 8 / this.scale;
          const bx = box.x;
          const by = box.y;
          const w = box.width;
          const h = box.height;

          const handles = [
            { x: bx, y: by, type: "nw" },
            { x: bx + w, y: by, type: "ne" },
            { x: bx + w, y: by + h, type: "se" },
            { x: bx, y: by + h, type: "sw" },
            { x: bx + w / 2, y: by, type: "n" },
            { x: bx + w, y: by + h / 2, type: "e" },
            { x: bx + w / 2, y: by + h, type: "s" },
            { x: bx, y: by + h / 2, type: "w" },
          ];

          for (let handle of handles) {
            if (
              x >= handle.x - handleSize / 2 &&
              x <= handle.x + handleSize / 2 &&
              y >= handle.y - handleSize / 2 &&
              y <= handle.y + handleSize / 2
            ) {
              return handle.type;
            }
          }
          return null;
        }

        resizeObject(mouseX, mouseY) {
          const obj = this.selectedObject;
          const handle = this.resizeHandle;

          if (!obj || !handle) return;

          const minSize = 10; // Minimum width/height

          switch (handle) {
            case "nw": // Top-left
              const newWidth = obj.x + obj.width - mouseX;
              const newHeight = obj.y + obj.height - mouseY;
              if (newWidth >= minSize && newHeight >= minSize) {
                obj.width = newWidth;
                obj.height = newHeight;
                obj.x = mouseX;
                obj.y = mouseY;
              }
              break;
            case "ne": // Top-right
              const neWidth = mouseX - obj.x;
              const neHeight = obj.y + obj.height - mouseY;
              if (neWidth >= minSize && neHeight >= minSize) {
                obj.width = neWidth;
                obj.height = neHeight;
                obj.y = mouseY;
              }
              break;
            case "se": // Bottom-right
              const seWidth = mouseX - obj.x;
              const seHeight = mouseY - obj.y;
              if (seWidth >= minSize && seHeight >= minSize) {
                obj.width = seWidth;
                obj.height = seHeight;
              }
              break;
            case "sw": // Bottom-left
              const swWidth = obj.x + obj.width - mouseX;
              const swHeight = mouseY - obj.y;
              if (swWidth >= minSize && swHeight >= minSize) {
                obj.width = swWidth;
                obj.height = swHeight;
                obj.x = mouseX;
              }
              break;
            case "n": // Top
              const nHeight = obj.y + obj.height - mouseY;
              if (nHeight >= minSize) {
                obj.height = nHeight;
                obj.y = mouseY;
              }
              break;
            case "s": // Bottom
              const sHeight = mouseY - obj.y;
              if (sHeight >= minSize) {
                obj.height = sHeight;
              }
              break;
            case "e": // Right
              const eWidth = mouseX - obj.x;
              if (eWidth >= minSize) {
                obj.width = eWidth;
              }
              break;
            case "w": // Left
              const wWidth = obj.x + obj.width - mouseX;
              if (wWidth >= minSize) {
                obj.width = wWidth;
                obj.x = mouseX;
              }
              break;
          }
        }

        placeObject(x, y) {
          switch (this.currentTool) {
            case "player":
              this.level.playerPos = { x, y };
              break;
            case "goal":
              this.level.goalPos = { x, y };
              break;
            case "box":
              this.level.objects.push({
                box: {
                  pos: { x, y },
                  width: 200,
                  height: 200,
                  canBounce: false,
                },
                zIndex: 0, // Default z-index for rendering order
              });
              break;
            case "pickup":
              this.level.objects.push({
                pickup: { pos: { x, y } },
              });
              break;
            case "shuriken":
              this.level.objects.push({
                shuriken: { pos: { x, y } },
              });
              break;
            case "rope":
              this.level.objects.push({
                ropeContactPoint: {
                  pos: { x, y },
                  endPos: { x, y }, // Default endpoint is same as start
                  canActivate: false,
                  isActive: true,
                },
              });
              break;
            case "laser":
              this.level.objects.push({
                laser: {
                  startPoint: { x, y },
                  endPoint: { x: x + 200, y }, // Default endpoint 200 pixels to the right
                },
              });
              break;
            case "background":
              // ...existing code...
              if (!this.level.background) {
                this.level.background = { positions: [] };
              }
              if (!this.level.background.positions) {
                this.level.background.positions = [];
              }
              // ...existing code...
              const positions = this.level.background.positions;
              if (positions.length < 2) {
                positions.push({ x, y });
              } else {
                let bestIndex = positions.length;
                let minDistance = Infinity;
                for (let i = 0; i < positions.length; i++) {
                  const p1 = positions[i];
                  const p2 = positions[(i + 1) % positions.length];
                  const distance = this.distanceToLineSegment(
                    x,
                    y,
                    p1.x,
                    p1.y,
                    p2.x,
                    p2.y
                  );
                  if (distance < minDistance) {
                    minDistance = distance;
                    bestIndex = i + 1;
                  }
                }
                positions.splice(bestIndex, 0, { x, y });
              }
              break;
          }
          this.render();
        }

        updatePropertyPanel() {
          const panel = document.getElementById("property-fields");
          panel.innerHTML = "";
          if (!this.selectedObject) return;
          const createInput = (label, value, callback) => {
            const input = document.createElement("input");
            input.type = "number";
            input.className = "property-input";
            input.placeholder = label;
            input.value = value;
            input.addEventListener("input", callback);
            const labelEl = document.createElement("label");
            labelEl.textContent = label;
            panel.appendChild(labelEl);
            panel.appendChild(input);
          };
          createInput("X", this.selectedObject.x, (e) => {
            this.selectedObject.x = parseFloat(e.target.value) || 0;
            this.updateObjectReference();
            this.render();
          });
          createInput("Y", this.selectedObject.y, (e) => {
            this.selectedObject.y = parseFloat(e.target.value) || 0;
            this.updateObjectReference();
            this.render();
          });
          if (this.selectedObject.type === "box") {
            createInput("Width", this.selectedObject.width, (e) => {
              this.selectedObject.width = parseFloat(e.target.value) || 1;
              this.updateObjectReference();
              this.render();
            });
            createInput("Height", this.selectedObject.height, (e) => {
              this.selectedObject.height = parseFloat(e.target.value) || 1;
              this.updateObjectReference();
              this.render();
            });
            createInput("Z-Index", this.selectedObject.zIndex || 0, (e) => {
              this.selectedObject.zIndex = parseInt(e.target.value) || 0;
              this.updateObjectReference();
              this.render();
            });
            // ...existing code for canBounce...
            const canBounceLabel = document.createElement("label");
            canBounceLabel.textContent = "Can Bounce";
            const canBounceInput = document.createElement("input");
            canBounceInput.type = "checkbox";
            canBounceInput.checked = this.selectedObject.canBounce || false;
            canBounceInput.addEventListener("change", (e) => {
              this.selectedObject.canBounce = e.target.checked;
              this.updateObjectReference();
              this.render();
            });
            panel.appendChild(canBounceLabel);
            panel.appendChild(canBounceInput);
          }
          if (this.selectedObject.type === "rope") {
            // ...existing code for canActivate and isActive...
            const canActivateLabel = document.createElement("label");
            canActivateLabel.textContent = "Can Activate";
            const canActivateInput = document.createElement("input");
            canActivateInput.type = "checkbox";
            canActivateInput.checked = this.selectedObject.canActivate || false;
            canActivateInput.addEventListener("change", (e) => {
              this.selectedObject.canActivate = e.target.checked;
              this.updateObjectReference();
              this.render();
            });
            panel.appendChild(canActivateLabel);
            panel.appendChild(canActivateInput);
            const isActiveLabel = document.createElement("label");
            isActiveLabel.textContent = "Is Active";
            const isActiveInput = document.createElement("input");
            isActiveInput.type = "checkbox";
            isActiveInput.checked = this.selectedObject.isActive !== false;
            isActiveInput.addEventListener("change", (e) => {
              this.selectedObject.isActive = e.target.checked;
              this.updateObjectReference();
              this.render();
            });
            panel.appendChild(isActiveLabel);
            panel.appendChild(isActiveInput);
            // Add inputs for end position
            createInput(
              "End X",
              this.selectedObject.endX ?? this.selectedObject.x,
              (e) => {
                this.selectedObject.endX = parseFloat(e.target.value) || 0;
                this.updateObjectReference();
                this.render();
              }
            );
            createInput(
              "End Y",
              this.selectedObject.endY ?? this.selectedObject.y,
              (e) => {
                this.selectedObject.endY = parseFloat(e.target.value) || 0;
                this.updateObjectReference();
                this.render();
              }
            );
          }
          if (this.selectedObject.type === "laser") {
            // Add inputs for laser end position
            createInput(
              "End X",
              this.selectedObject.endX ?? this.selectedObject.x + 200,
              (e) => {
                this.selectedObject.endX = parseFloat(e.target.value) || 0;
                this.updateObjectReference();
                this.render();
              }
            );
            createInput(
              "End Y",
              this.selectedObject.endY ?? this.selectedObject.y,
              (e) => {
                this.selectedObject.endY = parseFloat(e.target.value) || 0;
                this.updateObjectReference();
                this.render();
              }
            );
          }
          if (this.selectedObject.type === "backgroundPoint") {
            // ...existing code for backgroundPoint delete...
            const deleteBtn = document.createElement("button");
            deleteBtn.textContent = "Delete Point";
            deleteBtn.onclick = () => {
              if (
                this.selectedBackgroundPoint &&
                this.backgroundPointIndex !== -1
              ) {
                this.selectedBackgroundPoint.positions.splice(
                  this.backgroundPointIndex,
                  1
                );
                this.selectedObject = null;
                this.selectedBackgroundPoint = null;
                this.backgroundPointIndex = -1;
                this.updatePropertyPanel();
                this.render();
              }
            };
            panel.appendChild(deleteBtn);
          }
        }

        updateObjectReference() {
          if (this.selectedObject.type === "player") {
            this.level.playerPos.x = this.selectedObject.x;
            this.level.playerPos.y = this.selectedObject.y;
          } else if (this.selectedObject.type === "goal") {
            this.level.goalPos.x = this.selectedObject.x;
            this.level.goalPos.y = this.selectedObject.y;
          } else if (this.selectedObject.type === "backgroundPoint") {
            if (
              this.selectedBackgroundPoint &&
              this.backgroundPointIndex !== -1
            ) {
              this.selectedBackgroundPoint.positions[
                this.backgroundPointIndex
              ].x = this.selectedObject.x;
              this.selectedBackgroundPoint.positions[
                this.backgroundPointIndex
              ].y = this.selectedObject.y;
            }
          } else if (this.selectedObject.ref) {
            const ref = this.selectedObject.ref;
            if (ref.box) {
              ref.box.pos.x = this.selectedObject.x;
              ref.box.pos.y = this.selectedObject.y;
              ref.box.width = this.selectedObject.width;
              ref.box.height = this.selectedObject.height;
              ref.box.canBounce = this.selectedObject.canBounce;
              ref.zIndex = this.selectedObject.zIndex;
            } else if (ref.pickup) {
              ref.pickup.pos.x = this.selectedObject.x;
              ref.pickup.pos.y = this.selectedObject.y;
            } else if (ref.shuriken) {
              ref.shuriken.pos.x = this.selectedObject.x;
              ref.shuriken.pos.y = this.selectedObject.y;
            } else if (ref.ropeContactPoint) {
              ref.ropeContactPoint.pos.x = this.selectedObject.x;
              ref.ropeContactPoint.pos.y = this.selectedObject.y;
              ref.ropeContactPoint.canActivate =
                this.selectedObject.canActivate;
              ref.ropeContactPoint.isActive = this.selectedObject.isActive;
              // Update endPos
              if (!ref.ropeContactPoint.endPos) {
                ref.ropeContactPoint.endPos = {
                  x: this.selectedObject.endX ?? this.selectedObject.x,
                  y: this.selectedObject.endY ?? this.selectedObject.y,
                };
              } else {
                ref.ropeContactPoint.endPos.x =
                  this.selectedObject.endX ?? this.selectedObject.x;
                ref.ropeContactPoint.endPos.y =
                  this.selectedObject.endY ?? this.selectedObject.y;
              }
            } else if (ref.laser) {
              ref.laser.startPoint.x = this.selectedObject.x;
              ref.laser.startPoint.y = this.selectedObject.y;
              // Update endPoint
              if (!ref.laser.endPoint) {
                ref.laser.endPoint = {
                  x: this.selectedObject.endX ?? this.selectedObject.x + 200,
                  y: this.selectedObject.endY ?? this.selectedObject.y,
                };
              } else {
                ref.laser.endPoint.x =
                  this.selectedObject.endX ?? this.selectedObject.x + 200;
                ref.laser.endPoint.y =
                  this.selectedObject.endY ?? this.selectedObject.y;
              }
            }
          }
        }

        render() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.save();
          this.ctx.scale(this.scale, this.scale);
          this.ctx.strokeStyle = "#f0f0f0";
          this.ctx.lineWidth = 1 / this.scale;
          const gridSize = 50 / this.scale;
          const maxX = this.canvas.width / this.scale;
          const maxY = this.canvas.height / this.scale;
          for (let x = 0; x < maxX; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, maxY);
            this.ctx.stroke();
          }
          for (let y = 0; y < maxY; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(maxX, y);
            this.ctx.stroke();
          }
          const sortedObjects = [...this.level.objects].sort((a, b) => {
            const aZ = a.zIndex || 0;
            const bZ = b.zIndex || 0;
            return aZ - bZ;
          });
          sortedObjects.forEach((obj) => {
            if (obj.box) {
              this.ctx.fillStyle = "#8B4513";
              this.ctx.fillRect(
                obj.box.pos.x,
                obj.box.pos.y,
                obj.box.width,
                obj.box.height
              );
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.strokeRect(
                obj.box.pos.x,
                obj.box.pos.y,
                obj.box.width,
                obj.box.height
              );
              if (obj.box.canBounce) {
                this.ctx.strokeStyle = "white";
                this.ctx.lineWidth = 3 / this.scale;
                this.ctx.strokeRect(
                  obj.box.pos.x,
                  obj.box.pos.y,
                  obj.box.width,
                  obj.box.height
                );
              }
            }
            if (obj.pickup) {
              this.ctx.fillStyle = "#00ff00";
              this.ctx.beginPath();
              this.ctx.arc(
                obj.pickup.pos.x,
                obj.pickup.pos.y,
                15,
                0,
                Math.PI * 2
              );
              this.ctx.fill();
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.stroke();
            }
            if (obj.shuriken) {
              this.ctx.fillStyle = "#ff00ff";
              this.ctx.beginPath();
              this.ctx.arc(
                obj.shuriken.pos.x,
                obj.shuriken.pos.y,
                20,
                0,
                Math.PI * 2
              );
              this.ctx.fill();
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.stroke();
            }
            if (obj.ropeContactPoint) {
              // Draw rope endpoint line if endPos exists
              if (obj.ropeContactPoint.endPos) {
                this.ctx.strokeStyle = "#007bff";
                this.ctx.lineWidth = 2 / this.scale;
                this.ctx.beginPath();
                this.ctx.moveTo(
                  obj.ropeContactPoint.pos.x,
                  obj.ropeContactPoint.pos.y
                );
                this.ctx.lineTo(
                  obj.ropeContactPoint.endPos.x,
                  obj.ropeContactPoint.endPos.y
                );
                this.ctx.stroke();
                // Draw endpoint marker
                this.ctx.fillStyle = "#007bff";
                this.ctx.beginPath();
                this.ctx.arc(
                  obj.ropeContactPoint.endPos.x,
                  obj.ropeContactPoint.endPos.y,
                  10,
                  0,
                  Math.PI * 2
                );
                this.ctx.fill();
                this.ctx.strokeStyle = "black";
                this.ctx.lineWidth = 2 / this.scale;
                this.ctx.stroke();
              }
              // Choose color based on active state
              if (obj.ropeContactPoint.isActive === false) {
                this.ctx.fillStyle = "#808080";
              } else {
                this.ctx.fillStyle = "#8B4513";
              }
              this.ctx.beginPath();
              this.ctx.arc(
                obj.ropeContactPoint.pos.x,
                obj.ropeContactPoint.pos.y,
                40,
                0,
                Math.PI * 2
              );
              this.ctx.fill();
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.stroke();
              if (obj.ropeContactPoint.canActivate) {
                this.ctx.strokeStyle = "#FF6B35";
                this.ctx.lineWidth = 3 / this.scale;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(
                  obj.ropeContactPoint.pos.x,
                  obj.ropeContactPoint.pos.y,
                  45,
                  0,
                  Math.PI * 2
                );
                this.ctx.stroke();
                this.ctx.setLineDash([]);
              }
            }
            if (obj.laser) {
              // Draw laser line
              this.ctx.strokeStyle = "#ff0000";
              this.ctx.lineWidth = 4 / this.scale;
              this.ctx.beginPath();
              this.ctx.moveTo(obj.laser.startPoint.x, obj.laser.startPoint.y);
              this.ctx.lineTo(obj.laser.endPoint.x, obj.laser.endPoint.y);
              this.ctx.stroke();

              // Draw start point marker
              this.ctx.fillStyle = "#ff0000";
              this.ctx.beginPath();
              this.ctx.arc(
                obj.laser.startPoint.x,
                obj.laser.startPoint.y,
                15,
                0,
                Math.PI * 2
              );
              this.ctx.fill();
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.stroke();

              // Draw end point marker
              this.ctx.fillStyle = "#ff4444";
              this.ctx.beginPath();
              this.ctx.arc(
                obj.laser.endPoint.x,
                obj.laser.endPoint.y,
                10,
                0,
                Math.PI * 2
              );
              this.ctx.fill();
              this.ctx.strokeStyle = "black";
              this.ctx.lineWidth = 2 / this.scale;
              this.ctx.stroke();
            }
          });

          // Draw player
          this.ctx.strokeStyle = "black";
          this.ctx.lineWidth = 3 / this.scale;
          this.ctx.beginPath();
          this.ctx.arc(
            this.level.playerPos.x,
            this.level.playerPos.y,
            20,
            0,
            Math.PI * 2
          );
          this.ctx.stroke();

          // Draw goal
          this.ctx.fillStyle = "white";
          this.ctx.beginPath();
          this.ctx.arc(
            this.level.goalPos.x,
            this.level.goalPos.y,
            30,
            0,
            Math.PI * 2
          );
          this.ctx.fill();
          this.ctx.strokeStyle = "black";
          this.ctx.lineWidth = 3 / this.scale;
          this.ctx.stroke();

          // Draw background polygons on top of everything
          if (
            this.level.background &&
            this.level.background.positions &&
            this.level.background.positions.length > 2
          ) {
            const bg = this.level.background;
            // Draw polygon
            this.ctx.fillStyle = "rgba(200, 200, 255, 0.3)";
            this.ctx.strokeStyle = "rgba(100, 100, 200, 0.8)";
            this.ctx.lineWidth = 2 / this.scale;

            this.ctx.beginPath();
            this.ctx.moveTo(bg.positions[0].x, bg.positions[0].y);
            for (let i = 1; i < bg.positions.length; i++) {
              this.ctx.lineTo(bg.positions[i].x, bg.positions[i].y);
            }
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();

            // Draw points for editing (if background editing tool is selected)
            if (this.currentTool === "background") {
              bg.positions.forEach((pos, pointIndex) => {
                this.ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
                this.ctx.beginPath();
                this.ctx.arc(pos.x, pos.y, 8 / this.scale, 0, Math.PI * 2);
                this.ctx.fill();

                // Highlight selected point
                if (
                  this.selectedBackgroundPoint === bg &&
                  this.backgroundPointIndex === pointIndex
                ) {
                  this.ctx.strokeStyle = "#007bff";
                  this.ctx.lineWidth = 3 / this.scale;
                  this.ctx.beginPath();
                  this.ctx.arc(pos.x, pos.y, 12 / this.scale, 0, Math.PI * 2);
                  this.ctx.stroke();
                }
              });
            }
          }

          // Highlight selected object
          if (this.selectedObject) {
            this.ctx.strokeStyle = "#007bff";
            this.ctx.lineWidth = 3 / this.scale;
            if (this.selectedObject.type === "box") {
              this.ctx.strokeRect(
                this.selectedObject.x - 2,
                this.selectedObject.y - 2,
                this.selectedObject.width + 4,
                this.selectedObject.height + 4
              );

              // Draw resize handles for boxes
              this.drawResizeHandles(this.selectedObject);
            } else {
              const radius =
                this.selectedObject.type === "goal"
                  ? 32
                  : this.selectedObject.type === "rope"
                  ? 42
                  : this.selectedObject.type === "laser"
                  ? 17
                  : 22;
              this.ctx.beginPath();
              this.ctx.arc(
                this.selectedObject.x,
                this.selectedObject.y,
                radius,
                0,
                Math.PI * 2
              );
              this.ctx.stroke();

              // Draw laser endpoint highlight if it's a laser
              if (this.selectedObject.type === "laser") {
                this.ctx.beginPath();
                this.ctx.arc(
                  this.selectedObject.endX ?? this.selectedObject.x + 200,
                  this.selectedObject.endY ?? this.selectedObject.y,
                  12,
                  0,
                  Math.PI * 2
                );
                this.ctx.stroke();
              }
            }
          }

          // Restore context
          this.ctx.restore();
        }
      }

      const editor = new LevelEditor();

      function deleteSelected() {
        if (!editor.selectedObject) return;

        if (
          editor.selectedObject.type === "player" ||
          editor.selectedObject.type === "goal"
        ) {
          alert("Cannot delete player or goal!");
          return;
        }

        if (editor.selectedObject.ref) {
          const index = editor.level.objects.indexOf(editor.selectedObject.ref);
          if (index > -1) {
            editor.level.objects.splice(index, 1);
          }
        }

        editor.selectedObject = null;
        editor.updatePropertyPanel();
        editor.render();
      }

      function clearLevel() {
        if (confirm("Are you sure you want to clear the level?")) {
          editor.level.objects = [];
          editor.selectedObject = null;
          editor.updatePropertyPanel();
          editor.render();
        }
      }

      function exportLevel() {
        const level = editor.level;
        const code = `import { Vector } from "./Vector";

export default function getLevel() {
  return {
    playerPos: Vector(${level.playerPos.x}, ${level.playerPos.y}),
    goalPos: Vector(${level.goalPos.x}, ${level.goalPos.y}),
    background: { 
      positions: [${level.background.positions
        .map((pos) => `\n        Vector(${pos.x}, ${pos.y})`)
        .join(",")}
      ]
    },
    objects: [${level.objects
      .slice() // Create a copy to avoid modifying original
      .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0)) // Sort by z-index
      .map((obj) => {
        if (obj.box) {
          let boxStr = `\n      { box: { pos: Vector(${obj.box.pos.x}, ${obj.box.pos.y}), width: ${obj.box.width}, height: ${obj.box.height}`;

          // Add canBounce if it's true
          if (obj.box.canBounce) {
            boxStr += `, canBounce: ${obj.box.canBounce}`;
          }

          boxStr += ` } }`;
          return boxStr;
        }
        if (obj.pickup) {
          return `\n      { pickup: { pos: Vector(${obj.pickup.pos.x}, ${obj.pickup.pos.y}) } }`;
        }
        if (obj.shuriken) {
          return `\n      { shuriken: { pos: Vector(${obj.shuriken.pos.x}, ${obj.shuriken.pos.y}) } }`;
        }
        if (obj.ropeContactPoint) {
          const rope = obj.ropeContactPoint;
          let ropeStr = `\n      { ropeContactPoint: { pos: Vector(${rope.pos.x}, ${rope.pos.y})`;
          if (rope.endPos) {
            ropeStr += `, endPos: Vector(${rope.endPos.x}, ${rope.endPos.y})`;
          }
          if (rope.canActivate) {
            ropeStr += `, canActivate: ${rope.canActivate}`;
          }
          if (rope.isActive === false) {
            ropeStr += `, isActive: ${rope.isActive}`;
          }
          ropeStr += ` } }`;
          return ropeStr;
        }
        if (obj.laser) {
          const laser = obj.laser;
          return `\n      { laser: { startPoint: Vector(${laser.startPoint.x}, ${laser.startPoint.y}), endPoint: Vector(${laser.endPoint.x}, ${laser.endPoint.y}) } }`;
        }
        return "";
      })
      .join(",")}
    ],
  };
}`;

        document.getElementById("output").value = code;
      }

      function importLevel() {
        const code = document.getElementById("output").value.trim();
        if (!code) {
          alert("Please paste level code in the textarea first!");
          return;
        }

        try {
          // Parse the level code to extract the level data
          const levelData = parseLevelCode(code);

          // Update the editor with the imported data
          editor.level = levelData;

          // Add z-index to objects based on their order in the array
          if (editor.level.objects) {
            let boxIndex = 0;
            editor.level.objects.forEach((obj) => {
              if (obj.box) {
                // Assign z-index based on the order in the array
                obj.zIndex = boxIndex;
                boxIndex++;
              }
            });
          }

          editor.selectedObject = null;
          editor.updatePropertyPanel();
          editor.render();

          alert("Level imported successfully!");
        } catch (error) {
          alert("Error importing level: " + error.message);
        }
      }

      function parseLevelCode(code) {
        let objectContent;

        // Check if it's a complete function with return statement
        const returnMatch = code.match(/return\s*\{([\s\S]*)\}\s*;?\s*$/m);
        if (returnMatch) {
          // Extract content from return statement
          objectContent = returnMatch[1].trim();
        } else {
          // Assume it's just the object content directly
          objectContent = code.trim();
          // Remove outer braces if present
          if (objectContent.startsWith("{") && objectContent.endsWith("}")) {
            objectContent = objectContent.slice(1, -1).trim();
          }
          // Remove trailing semicolon if present
          objectContent = objectContent.replace(/;\s*$/, "");
        }

        // Remove any trailing comma
        objectContent = objectContent.replace(/,\s*$/, "");

        // Parse using a simple approach - convert Vector() calls to a parseable format
        const jsonString = `{${objectContent}}`
          .replace(/Vector\s*\(\s*([^)]+)\s*\)/g, (match, args) => {
            const [x, y] = args.split(",").map((s) => s.trim());
            return `{"x": ${x}, "y": ${y}}`;
          })
          .replace(/(\w+):/g, '"$1":') // Quote property names
          .replace(/\/\/[^\n\r]*/g, "") // Remove comments
          .replace(/,\s*}/g, "}") // Remove trailing commas
          .replace(/,\s*]/g, "]"); // Remove trailing commas in arrays

        try {
          const levelObj = JSON.parse(jsonString);
          return levelObj;
        } catch (e) {
          throw new Error("Could not parse level object: " + e.message);
        }
      }
    </script>
  </body>
</html>
